const Log = require( '../methods/log' ),
    Search = require( './Search' ),
    dbConnection = require( './connection' ),
    AggrMethods = require( './AggrMethods' );

/**
 * Aggregation
 * Sugar aggregation builder, through chained methods.
 * @param {Model} modelORM Promised-mongo collection object
 * @return {Promise}
 */
module.exports = function Aggregation( collection ) {

    // Create an array
    let aggregation = [];

    // Link methods
    AggrMethods.forEach( verb => {
        aggregation[ verb ] = wraper( verb );
    } );

    // Wrap into a verb
    function wraper( verb ) {
        return ( param ) => {

            // Wrap in the $verb
            let step = {};
            step[ '$' + verb ] = param;

            // Add to aggregation and chain
            aggregation.push( step );
            return aggregation;

        };
    }

    // Execute aggregation when CB is set
    aggregation.then = function ( success, failed ) {

        let prom = new Promise( ( resolve, reject ) => {

            dbConnection( collection )
                .then( async db => {
                  if (!db.aggregate)
                    return Log.error(
                      'Aggregation not available on %o',
                      collection
                    );

                  // Pass the pipeline, the Callbacks and return the Promise
                  let cursor = db.aggregate(aggregation, {
                    cursor: {},
                    allowDiskUse: true,
                  });

                  // data to return
                  let data = [];

                  try {
                    let doc = undefined;
                    while ((doc = await cursor.next())) {
                      data.push(doc);
                    }
                    await cursor.close();
                    resolve(data);
                  } catch (e) {
                    reject(e);
                  }
                }, reject);

        } );

        if ( success ) {
            if ( failed )
                prom.then( success, failed );
            else
                prom.then( success );
        }

        return prom;

    };

    // Add a search sugar builder
    aggregation.search = function ( needle, fields ) {
        if ( !needle ) return aggregation;
        return aggregation.match( Search( needle, fields ) );
    };

    aggregation.populateBy = function () {
      return aggregation
          .lookup({
              from: 'users',
              foreignField: '_id',
              localField: 'createdBy',
              as: '_createdBy'
          })
          .unwind({
              path: '$_createdBy',
              preserveNullAndEmptyArrays: true
          })
          .lookup({
              from: 'users',
              foreignField: '_id',
              localField: 'updatedBy',
              as: '_updatedBy'
          })
          .unwind({
              path: '$_updatedBy',
              preserveNullAndEmptyArrays: true
          })
          .addFields({
            createdBy: {
              $cond:{
                if: { $ne : ['$_createdBy', undefined] },
                then: {
                  _id: '$_createdBy._id',
                  firstName: '$_createdBy.firstName',
                  lastName: '$_createdBy.lastName',
                },
                else: undefined
              }
            },
            updatedBy: {
              $cond:{
                if: { $ne : ['$_updatedBy', undefined] },
                then: {
                  _id: '$_updatedBy._id',
                  firstName: '$_updatedBy.firstName',
                  lastName: '$_updatedBy.lastName',
                },
                else: undefined
              }
            },
          })
          .project({
            _createdBy: 0,
            _updatedBy: 0,
          });
    };

    // Return the aggregation array/builder
    return aggregation;

};
