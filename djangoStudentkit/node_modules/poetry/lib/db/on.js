const dbConnection = require( './connection' );
const Log = require( '../methods/log' );

const DEBUG = process.env.debug || process.env.DEBUG;

// Triggers the callback foreach filter result when there is one.
module.exports = (collection) => async (filter, wait, cb) => {
  // If there is no "wait", set the default to 5s.
  if (!cb) {
    cb = wait;
    wait = 5000;
  }

  // We loop forever
  while(true) {
    try {
      let start = Date.now();
      let nbData = 0;
      // Get the next batch or wait for it
      const next = await getNext(collection, filter, wait);

      nbData = next.length;

      if (nbData) {
        if (DEBUG) {
          Log.debug(`[Collection.on time] ${collection}: DB Request ${Date.now() - start} ms`);
        }
      }

      // Launch the CB for each item of the batch
      while(next.length) {
        // We get the next one
        const n = next.shift();

        // We execute the CB (assure to have a promise if the CB is sync)
        await new Promise(resolve => resolve(cb(n)));
      }

      if (nbData && DEBUG) {
        Log.debug(`[Collection.on time] ${collection}: Done ${Date.now() - start} ms`);
      }

      await sleep(100);
    } catch(e) {
      Log.error('Poetry.on error %o', e);
      return process.exit(1);
    }
  }
};

// Retrieves the batch or wait for it
async function getNext(collection, filter, wait) {
  // Ask the database
  let next = await getFromDB(collection, filter);

  // While we don't have a result, wait and retry
  while(!(next && next.length)) {
    await sleep(wait);
    next = await getFromDB(collection, filter);
  }

  // Return the result when we finally have some
  return next;
}


// Waiting as a promise
function sleep(duration) {
  return new Promise(resolve => setTimeout(() => resolve(), duration));
}

// Ask the DB
async function getFromDB(collection, filter) {
  // Get the facade of the collection
  let db = await dbConnection(collection);

  // Execute the find, limited to a 1000 items batch
  let r = db.find(filter).limit(1000);
  if ( r.toArray ) {
    r = r.toArray();
  }
  return r;
}
