const { Module } = require('module');
var DB = require( '../db/query.js' );
var subscribe = require('./subscribe.js');
var publish = require('./publish.js');
var Log = require( '../methods/log' );
var ifcs = require( 'os' )
    .networkInterfaces();
var service = 'unknown service',
    address = '';

try {
    var pkg = require( process.cwd() + '/package.json' );
    service = pkg.name || service;
} catch ( e ) {}

try {
    address = ifcs.eth0[ 0 ].address;
} catch ( e ) {}

var watchers = [];
var interval = 10000;
let MODE = {
    db: (process.env.mode || '').includes('db'),
    kafka: (process.env.mode || '').includes('kafka'),
};
if (!MODE.db && !MODE.kafka) MODE.db = true;
module.exports.services = [service];

module.exports.on = function on( eventName, pattern, cb ) {
    Log.warn('DEPRECATED, use kafka : Poetry.on', eventName);
    if (MODE.db) {
        if ( !pattern ) pattern = {};
        watchers.push( {
            eventName: eventName,
            pattern: pattern,
            cb: cb,
            lastWatch: new Date()
        } );
    }
    if (MODE.kafka) {
        var tmp = replaceTopic(eventName);
        subscribe(tmp,cb);
    }
};

module.exports.emit = function emit( eventName, message ) {
    Log.warn('DEPRECATED, use kafka : Poetry.emit', eventName);
    if (MODE.db) {
        try {
            DB( 'poetry_events', 'insert' )( {
                    name: eventName,
                    message: [ message ],
                    service: service,
                    address: address
                } )
                .then( function ( ev ) {
                    if (ev) Log.verbose( `ðŸ“¤  Event emited: ${eventName} (${ev._id})` );
                }, () => {} );
        } catch ( e ) {
            Log.warn( `Event not emited: ${eventName}` );
            Log.error( e );
        }
    }
    if (MODE.kafka) {
        var tmp = replaceTopic(eventName);
        publish(tmp, message);
    }
};

function replaceTopic(eventName) {
    var tmp = eventName.replace(/[^a-zA-Z0-9]+/g, '-');
    return tmp;
}

function watcher( watch, i ) {
    DB( 'poetry_events', 'find' )( {
            name: watch.eventName,
            // message: {
            //     $elemMatch: watch.pattern
            // },
            createdAt: {
                $gt: watch.lastWatch
            }
        } )
        .sort( {
            createdAt: 1
        } )
        .then( function ( events ) {
            if ( !events || !events.length ) return;
            events.forEach( e => {
                Log.verbose( `ðŸ“¥  Event from ${e.service} : ${e.name} (${e._id})`);
                watch.cb( e.message[ 0 ], {
                    name: e.service,
                    address: e.address,
                    timestamp: e.createdAt,
                    uuid: e._id
                } );
                if(!~module.exports.services.indexOf(e.service))
                    module.exports.services.push(e.service);
            } );
            watchers[ i ].lastWatch = events[ events.length - 1 ].createdAt;
        }, ( e ) => {
            Log.error( 'FATAL ERROR retrieving events' );
            Log.error( e );
            process.exit();
        } );
}

if (MODE.db) {
    setInterval( function () {
        watchers.forEach( watcher );
    }, interval );
}


setInterval( function () {
    let timedout = new Date();
    timedout.setHours( timedout.getHours() - 1 );
    try {
        DB( 'poetry_events', 'delete' )( {
                createdAt: timedout
            } )
            .then( () => {} );
    } catch ( e ) {}
}, 60 * 60000 );
