const Models = require( '../../models' ),
    Session = require('../redis/internal').session,
    Log = require( './log' ),
    Bcrypt = require( 'bcrypt' );

const Users = Models.users,
    Teams = Models.teams,
    Sessions = Models.sessions,
    Logs = Models.logs,
    ApiKeys = Models.ApiKeys;


module.exports = function login( email, password, isMobile, host, path ) {

    email = email.toLowerCase();

    return new Promise( ( resolve, reject ) => {

        if ( !~email.indexOf( '.' ) && email.length == 24 ) getAPIKey();
        else getUsers();

        function getAPIKey() {
            Log.silly( 'APIKEY %s', email );
            ApiKeys.findOne( {
                    _id: Models.ObjectId( email )
                } )
                .then( apikey => {
                    if ( !apikey ) return reject( 'Wrong authentication' );
                    Users.findOne( {
                            _id: Models.ObjectId( apikey.user ),
                            status: {
                                $in: [ 'active', 'new', 'apionly' ]
                            }
                        } )
                        .then( user => populateUser(user, apikey.secret, true), reject );
                }, reject );
        }

        function getUsers() {
            Users.findOne( {
                    email: email,
                    status: {
                        $in: [ 'active', 'new' ]
                    }
                } )
                .then( user => {
                    if ( !user ) return reject( "Wrong authentication" );

                    if ( !user.password )
                        return reject( "No password set" );
                    populateUser( user, user.password );
                }, reject );
        }

        function populateUser( user, pwd, maybeUnencrypted ) {
            // If there is no user
            Log.silly( 'ðŸ‘¤  User %s', user.email );
            checkPWD( user, pwd, maybeUnencrypted );
        };

        function checkPWD( user, pwd, maybeUnencrypted ) {

            if(maybeUnencrypted && pwd === password)
                return newSession(user);

            // Check password
            if ( !Bcrypt.compareSync( password, pwd ) )
                return reject( "Wrong authentication" );

            newSession( user );
        }

        function newSession( user ) {

            // Cleaning user
            delete user.password;
            user._id = user._id.toString();

            // Define new session
            let id = ( Math.random() * 0xFFFFFFFFFFFFFF )
                .toString( 32 );
            id += '107F4C70RY';
            id += ( Math.random() * 0xFFFFFFFFFFFFFE )
                .toString( 32 );
            let session = {
                _id: id,
                isAuthenticated: true,
                user: user
            };

            // If there's no team, resolve
            if ( user.team ) getTeam( session );
            else doResolve( session );

        }


        function getTeam( session ) {
            Teams.findOne( {
                    _id: session.user.team
                } )
                .then( team => {
                    session.team = team;
                    checkMobileToken( session.user, team, session )
                        .then( () => populateTeam( session ), reject );
                }, reject );
        }

        function populateTeam( session ) {
            let userId = session.user._id;
            try {
                userId = Models.ObjectID( userId );
            } catch ( e ) {}

            let roleId = session.user.role;
            try {
                roleId = Models.ObjectID( roleId );
            } catch ( e ) {}

            let logsData = {
                user: userId,
                method: "post",
                path: path,
                params: {},
                team: session.user.team,
                role: roleId
            }

            // Log the authentication access in the DB :
            // because not going through 'onPreAuth' server extension function
            // =>so insert logs here
            Logs.insert( logsData )
                .then( () => {} );

            doResolve( session );
        }

        function doResolve(session) {
            let formattedSession = session;
            // save session
            try {
                formatSessionId(session);
            } catch(e) {
                Log.error(e);
            }
    
            // resolve session
            resolve(formattedSession);
        }
    } );

    function checkMobileToken( user, team, session ) {

        Log.silly( 'Login checkMobileToken' );

        return new Promise( async ( resolve, reject ) => {
            if ( !( team && team.maxUsers && team.maxUsers > 0 ) ) {
                return resolve( session );
            }

            if ( !isMobile ) {
                let queryRemove = {
                    user: user._id,
                    $or: [ {
                            isMobile: {
                                $exists: false
                            }
                        },
                        {
                            isMobile: {
                                $ne: true
                            }
                        }
                    ]
                };

                try {
                    if (Session) {
                        try {
                          // retrieve sessions from user where isMobile is not set
                          let res = await Sessions.distinct('_id', queryRemove);
                          await Sessions.remove(queryRemove);
                          try {
                            for (const id of res) {
                              try {
                                // delete from cache
                                await Session.del(id);
                              } catch (e) {
                                Log.error(e);
                              }
                              Log.silly('Removed old session');
                            }
                          } catch (e) {
                            Log.error(e);
                          }
                          await Sessions.remove(queryRemove);
                        } catch (err) {
                          Log.error(err);
                        }
                        resolve(session);
                    } else {
                        Sessions.remove(queryRemove).then(
                          (res) => {
                            let r = {};
                            try {
                              r.n = res.n;
                              r.ok = res.ok;
                            } catch (e) {}
                            Log.silly('Removed old session %o', r);
                            resolve(session);
                          },
                          (err) => {
                            Log.error(err);
                            resolve(session);
                          }
                        );
                    }
                } catch(e) {
                    Log.error(e);
                }
                
            } else {
                Log.silly( 'A MOBILE IT IS' );
                session.isMobile = true;

                // if a token already exists,
                // create "tmpAccess" session
                if ( user.mobileToken ) {
                    Log.silly( 'A MOBILE TOKEN already exists' );
                    //return reject( "You are already connected" );
                    session.tmpAccess = true;
                    return resolve( session );
                }

                let userId;
                try {
                    userId = Models.ObjectID( user._id );
                } catch ( e ) {
                    userId = user._id;
                }

                Users.findAndModify( {
                        query: {
                            _id: userId
                        },
                        update: {
                            '$set': {
                                mobileToken: session._id
                            }
                        },
                        new: true
                    } )
                    .then( userUpdated => {
                        if ( !userUpdated ) {
                            Log.debug( 'Error updating USER mobileToken' );
                            return reject( 'Error updating USER mobileToken' );
                        }
                        userUpdated._id = userUpdated._id.toString();
                        session.user = userUpdated;
                        resolve( session );
                    } )
                    .catch( err => {
                        Log.debug( err );
                        return reject( err );
                    } );
            }
        } );

    }

    function formatSessionId(session) {
        if (!session._id) {
            if ( Object.keys( request.session )
                .length <= 1 )
                return session;
    
            session._id = ( ( Math.random() * 0xFFFFFFFFFFFFFF )
                .toString( 32 ) + ( Math.random() * 0xFFFFFFFFFFFFFF )
                .toString( 32 ) );
        }
    }
};
