var Log = require( '../methods/log' );

/**
 * Poetry.subscribe
 * Listen to kafka topic
 * @param {object} topic Kafka topic we are listening to
 * @param {function} handler Async function receiving the message (message)
 * @returns {void} void
 */

var service = 'poetry';
try {
  var pkgServ = require( process.cwd() + '/package.json' );
  service = process.env.service_name || pkgServ.name;
  service = service.replace(/[^a-zA-Z0-9]+/g, '-');
} catch ( e ) {}

const getKafka = require('../getKafka');


module.exports = async function subscribe(topic, handler, conf) {
  Log.info(`ðŸ‘‚  Subscribing KAFKA topic "${topic}"`);

  // Get kafka consumer
  const consumer = await getKafkaConsumer(topic, conf);

  // If we don't have a consumer, abort
  if (!consumer) return;

  Log.info('test subscribe');
  // Listen to the topic
  await consumer.subscribe({
    topic,
  });

  const admin = await getKafkaAdmin();
  if (admin) {
    try {
      const partitions = await admin.fetchTopicOffsets(topic);
      if(partitions) {
        partitions.forEach(function (partition) {
          Log.info(`ðŸ‘‚ Start "${topic}" offset: ${partition.offset} | hight: ${partition.high} | low: ${partition.low}`);
        })
      }
    } catch (error) {
      Log.error(error)
    }

    await admin.disconnect();
  }

  await consumer.run({
    eachBatchAutoResolve: false,
    eachBatch: async ({
      batch,
      resolveOffset,
      heartbeat,
    }) => {
      Log.verbose( `ðŸ“¥  Received from KAFKA topic "${topic}" (${batch.messages.length} messages)`);
      for (let message of batch.messages) {
        try {
          let sender = {};
          try {
            // unbufferize header values
            Object.keys((message.headers || {})).forEach(key => {
              if (message.headers[key] && typeof message.headers[key].toString === 'function') {
                sender[key] = message.headers[key].toString('utf8');
              }
            });
            sender.name = sender.service;
            sender.timestamp = message.timestamp;
            sender.uuid = message.offset;
          } catch(e) {
            Log.error(`Poetry.subscribe('${topic}', â€¦) error:`, e);
          }
          const res = handler(
            JSON.parse(message.value.toString()),
            sender
          );

          if (res && res.then) await res;
          await resolveOffset(message.offset);
          Log.debug( `ðŸ“¥  Resolved offset ${message.offset} from KAFKA topic "${topic}"`);
        } catch (e) {
          Log.error(`Poetry.subscribe('${topic}', â€¦) handler throwed an error:`, e);
        }
        await heartbeat();
      }
    },
  });
}

// Get the consumer
async function getKafkaConsumer(topic, config) {

  if(!(config && typeof config == 'object')) {
    config = {}
  }

  // Get kafka connection
  const kafka = await getKafka();

  // If we don't have a connection, abort
  if (!kafka) return;

  config.groupId = `${service}---${topic}`;
  config.readUncommitted = true;

  const consumer = kafka.consumer(config);
  await consumer.connect();

  return consumer;
}

async function getKafkaAdmin(topic) {
  // Get kafka connection
  const kafka = await getKafka();

  // If we don't have a connection, abort
  if (!kafka) return;

  const admin = kafka.admin();
  await admin.connect();
  return admin;
}
