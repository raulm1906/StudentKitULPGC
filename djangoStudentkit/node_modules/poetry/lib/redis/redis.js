const Log = require( '../methods/log' );
const Redis = require('ioredis');
const JSONCache = require('redis-json');
const isActive = require('./isActive');
const Models = require('../../models');
const ObjectID = Models.ObjectID;

const DEBUG_REDIS = process.env.DEBUG_REDIS;

/**
 * @type import('ioredis').Redis
 */
let redisClient;
if (isActive()) {
  if (DEBUG_REDIS) Log.warn('REDIS CONNECTING ...');
  try {
    redisClient = new Redis({
      port: process.env.REDIS_PORT, // Redis port
      host: process.env.REDIS_HOST, // Redis host
      password: process.env.REDIS_PASSWORD,
      maxRetriesPerRequest: 1,
      retryStrategy(times) {
        let seconds = times;
        
        if (times < 10) {
          seconds = times; // less then 10 seconds
        } else if (times < 16) { // 6 * 5 min = 30 min
          seconds = 60 * 5; // 5 min
        } else if (times < 22) { // 6 * 10 min = 1 h
          seconds = 60 * 10; // 10 min
        } else {
          seconds = 60 * 30; // 30 min
        }
        const delay = Math.min(seconds * 1000, 3600000);
        return delay;
      },
    });
    redisClient.on('ready', function() {
      Log.info('REDIS CLIENT CONNECTED');
    });
  } catch (e) {
    Log.error('REDIS CLIENT ERROR:', e);
    console.error(e);
  }
}

/**
 * Wraps redis client
 * @param {*} name
 * @param {*} setOptions
 * @returns {{redisJson: Object, get: Function, set: Function, del: Function}}
 */
module.exports = function getCache(name, setOptions) {
  let jsonCache;
  if(!redisClient) {
    return;
  }
  setOptions = setOptions || {
    expire: 60 * 5, // in seconds
  };
  try {
    const stringifier = {
      Date: (val) => val.toISOString(),
    };
    const parser = {
      Date: (str) => new Date(str),
    };
    if (ObjectID) {
      stringifier.ObjectID = (val) => {
        if (DEBUG_REDIS) Log.debug('stringify from object id')
        return val.toString()
      };
      parser.ObjectID = (str) => {
        if (DEBUG_REDIS) Log.debug('parsing to object id')
        return ObjectID(str)
      };
    }
    jsonCache = new JSONCache(redisClient, {
      prefix: `${name}:`,
      stringifier,
      parser,
    });
  } catch (e) {
    Log.error('REDIS CACHE ERROR:', e);
    console.error(e);
  }

  let result;
  if (jsonCache) {
    result = createCacheHandler(jsonCache, setOptions);
  }

  return result;
};

function isStatusOk() {
  const status = redisClient ? redisClient.status : '';
  const r = (status == 'connect' || status == 'ready');
  return r;
}

function createCacheHandler(redisJson, setOptions) {
  return {
    redis: redisClient,
    redisJson,
    async get(id) {
      let r;
      if (isStatusOk()) {
        try {
          if (DEBUG_REDIS) Log.silly(`REDIS get ${redisJson.getKey(id)}`);
          r = await redisJson.get(`${id}`);
          let strR = JSON.stringify(r);
          if (DEBUG_REDIS) Log.silly(`REDIS got`, strR);
          //if (DEBUG_REDIS) Log.silly(`REDIS got ${strR ? strR.substring(0, 64) + '...' : strR}`);
        } catch (e) {
          Log.error(e);
        }
      }
      return r;
    },
    async set(id, obj, options) {
      let r;
      if (isStatusOk()) {
        try {
          await redisJson.del(`${id}`);
          if (DEBUG_REDIS) Log.silly(`REDIS set ${redisJson.getKey(id)}`, JSON.stringify(obj));
          r = await redisJson.set(`${id}`, obj, options || setOptions);
        } catch (e) {
          Log.error(e);
        }
      }
      return r;
    },
    async del(id) {
      let r;
      if (isStatusOk()) {
        try {
          if (DEBUG_REDIS) Log.silly(`REDIS del ${redisJson.getKey(id)}`);
          r = await redisJson.del(`${id}`);
        } catch (e) {
          Log.error(e);
        }
      }
      return r;
    },
    async keys(pattern) {
      let r;
      if (isStatusOk()) {
        try {
          if (DEBUG_REDIS) Log.silly(`REDIS keys by pattern: ${redisJson.getKey(pattern)}`);
          r = await redisClient.keys(redisJson.getKey(pattern));
        } catch(e) {
          Log.error(e);
        }
      }
      return r;
    }
  };
}
