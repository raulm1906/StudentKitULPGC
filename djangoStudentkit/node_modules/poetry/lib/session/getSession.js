const Log = require( '../methods/log' ),
    Models = require( '../../models' ),
    BasicAuth = require( './basicAuth' ),
    SessionUtils = require('./utils'),
    ObjectID = Models.ObjectID,
    Logs = Models.logs;

const Boom = require( 'boom' );

module.exports = async function sessionMiddleware( request, reply ) {
    let cookie = request.state.session;

    if ( request.headers.authorization ) {
        // Basic HTTP auth
        if ( request.headers.authorization.indexOf( 'Basic' ) === 0 )
            return BasicAuth( request )
                .then( (s) => {
                    if ( !s ) {
                        request.session = {
                            _id: cookie
                        };
                        Log.silly( 'No session' );
                    } else {
                        request.session = s;
                    }
                    return delegate();
                } )
                .catch( err => {
                    Log.error(err);
                    reply( err ).code( 401 );
                });

        // Session token auth
        if ( request.headers.authorization.indexOf( 'Session' ) === 0 )
            cookie = request.headers.authorization.slice( 8 );
    }

    if ( !cookie ) {
        request.session = {};
        return delegate();
    }

    // Get the session from the DB
    var tooLate,
        countdown = setTimeout( () => {
            tooLate = true;
            reply( Boom.failedDependency( "Database did not responded in time for retrieving session" ) );
        }, 2000 );

    Log.silly( `[${request.headers['X-RequestUID']}] 🍪  Cookie ${JSON.stringify( cookie )}`);

    try {
        let session = await SessionUtils.getSession(cookie);
        clearTimeout(countdown);
        if (tooLate) {
            return Log.error(
              'Database did not responded in time for retrieving session'
            );
        }
        await sessionRetrieved(session);
    } catch(e) {
        error('Cannot retrieve SESSION')(e);
    }

    /**
     * sessionRetrieved
     * Connect potential user through given session
     *
     * @param {object} session Session retrieved
     */
    async function sessionRetrieved( session ) {

        // No session
        if ( !session ) {
            request.session = {
                _id: cookie
            };
            Log.silly( 'No session' );
            return delegate();
        }

        Log.silly( `[${request.headers['X-RequestUID']}] 🏷  Session ${session._id} ${session.keep?'KEEP':'TEMP'}: ${session.user} (${session.team})` );

        // Add the found session to request
        request.session = session;

        // If there's no user, delegate
        if ( !session.user)
            return delegate();

        // Populate user
        try {
            if (session._cache) {
                await populateUser(session.user);
            } else {
                let user = await SessionUtils.getUserById(session.user);
                await populateUser(user);
            }
        } catch(e) {
            error( 'Cannot retrieve user' )(e);
        }
    }

    async function populateUser( user ) {
        if (!user) {
            request.session = {};
            return delegate();
        }

        try {
            if (ObjectID) {
                user._id = ObjectID(user._id);
            }
        } catch(e) {
            Log.error(e);
        }

        // Log the access in the DB
        Logs.insert( {
                user: user._id,
                method: request.method,
                path: request.path,
                params: request.params,

                // usefull for the research
                team: user.team,
                role: user.role,
                requestId: request.headers['X-RequestUID'],
            } )
            .then( () => {}, () => {} );

        // Store populated user in request.session
        request.session.user = user;

        // If there's no team, delegate
        if ( !user || !user.team ) return reply.continue();
        if ( user.team == "test" ) {
            request.session.team = {
                _id: "test"
            };
            return delegate();
        }

        // Populate team
        try {
            if (request.session._cache) {
                await checkMobileToken( user, request.session.team, request.session );
            } else {
                let team = await SessionUtils.getTeamById(user.team);
                request.session.team = team;
                await checkMobileToken( user, team, request.session );
            }
            delegate();
        } catch(e) {
            error( 'Cannot retrieve TEAM' )(e);
        }
    }

    function checkMobileToken( user, team, session ) {
        const isMobile = request.headers[ "user-agent" ] && request.headers[ "user-agent" ].indexOf( "Mobi" ) > -1;
        if ( isMobile ) {
            Log.silly( `[${request.headers['X-RequestUID']}] Mobile session detected via "${request.headers[ "user-agent" ]}"`);
        }

        return new Promise( ( resolve, reject ) => {
            if ( request.session.isWeb ) {
                // do nothing
            } else if ( isMobile && !session.tmpAccess && team && team.maxUsers && team.maxUsers > 0 && user.mobileToken && session && user.mobileToken !== session._id ) {
                Log.verbose(`[${request.headers['X-RequestUID']}] Session "${session._id}" differs from MobileToken "${user.mobileToken}"`);
                return reject( 'A mobile session already exists.' );
            }
            resolve();
        } );
    }

    function delegate() {
        return reply.continue();
    }

    function error( message ) {
        return err => {
            Log.error( `[${request.headers['X-RequestUID']}] Error durring getSession %o %o`, message, err );

            request.session = {};
            return reply.continue();
        };
    }
};
