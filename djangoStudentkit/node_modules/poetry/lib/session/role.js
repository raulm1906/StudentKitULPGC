const Boom = require( 'boom' ),
    Log = require( '../methods/log.js' ),
    DB = require( '../../models.js' );

const ObjectID = DB.ObjectID,
    UserGroups = DB.UserGroups,
    Solutions = DB.Solutions;

const BASIC_ROLES = [
    '*',
    'SUPER',
    'PARTNER'
]; 

var solutionsUrls = [],
    solutionsKeys = [];

// Populating solutions
Solutions.find( {} )
    .then( sol => {
        if(sol)
            sol.forEach( s => {
                if ( s.urls )
                    s.urls.forEach( so => {
                        if ( !~solutionsUrls.indexOf( so ) )
                            solutionsUrls.push( so );
                    } );
                if ( s.apiKeys )
                    s.apiKeys.forEach( so => {
                        if ( !~solutionsKeys.indexOf( so ) )
                            solutionsKeys.push( so );
                    } );
            } );
    } );

module.exports = function checkRole( request, reply ) {
    let auth = request.route.settings.plugins.poetryAuth;
    let tmpAccess = request.route.settings.plugins.tmpAccess;
    let basicRoleAccess = request.route.settings.plugins.basicRoleAccess;

    let referer = request.headers.referer;
    try {
        referer = referer.split( '/' )[ 2 ];
    } catch ( e ) {}

    process.nextTick( () => {
        // Avoid unknown property issue
        request.session.role = request.session.role || {};

        // No auth check needed
        if ( !auth )
            return reply.continue();

        // check tmp access
        if (request.session.tmpAccess
            && request.method != 'options' && request.method != 'OPTIONS') {
            Log.debug(`[${request.headers['X-RequestUID']}] ⏱  TmpAccess : ${tmpAccess}`);
            if(!tmpAccess) {
                return reply( Boom.unauthorized() );
            }
        }

        // Not logged on
        if ( !request.session.isAuthenticated || !request.session.user ) {
            Log.warn(`[ checkRole ${request.session._id}] not authenticated`);
            return reply( Boom.unauthorized('Not authenticated') );
        }

        if (basicRoleAccess && typeof basicRoleAccess === 'string') {
            if (BASIC_ROLES.indexOf(basicRoleAccess) > BASIC_ROLES.indexOf(request.session.user.role)) {
                return reply( Boom.forbidden('Not the proper permissions') );
            }
        }

        // PARTNER case
        if ( request.session.user.role == 'PARTNER' )
            return reply.continue();

        // SUPER case
        if ( request.session.user.role == 'SUPER' )
            return reply.continue();

        // ADMIN case
        if ( request.session.user.role == '*' )
            return roles( {
                name: "ADMIN",
                permissions: request.session.team.permissions
            } );

        // USER case
        if (request.session._cache) {
            roles(request.session.role)
        } else {
            let id;
        try {
            id = ObjectID( request.session.user.role );
        } catch ( err ) {
            Log.error( `[${request.headers['X-RequestUID']}] User "${request.session.user.email}" have an unknown role "${request.session.user.role}"`);
            return reply( Boom.forbidden() );
        }
        UserGroups.findOne( {
            _id: id,
            team: request.session.team._id
        } )
        .then( roles, roles );
        }
    } );

    function roles( role ) {
        // PARTNER case
        if ( request.session.user.role == 'PARTNER' )
            return reply.continue();
        // SUPER case
        if ( request.session.user.role == 'SUPER' )
            return reply.continue();

        if ( !role ) {
            Log.warn( `[${request.headers['X-RequestUID']}] User "${request.session.user.email}" have an unknown role "${request.session.user.role}"`);
            return reply( Boom.forbidden('User group does not exist') );
        }

        request.session.role = role;

        // Always allow /users/me
        if ( ~[
                '/api/users/me',
                '/api/users/changePwd',
                '/api/users/homepage'
            ].indexOf( request.route.path ) ) return reply.continue();

        // Special handwritten auths
        if ( Array.isArray( auth ) ) {
            if(auth.some( tag => {
                const customRole = `API.${tag}.${request.route.settings.description}`;
                if (check( customRole, role.permissions)) {
                    return Log.silly(`[${request.headers['X-RequestUID']}] Custom role found "${customRole}"` );
                }
            })) return true;
        }

        /*
        IN SOME CASES, REFERER IS UNDEFINED
        if ( !referer || !~solutionsUrls.indexOf( referer ) ) {
            Log.warn(`[ checkRole ${request.session._id}] Incorrect hostname: referer = ${referer}`);
            return reply( Boom.forbidden( 'Incorrect hostname' ) );
        }*/

        if ( request.route.settings.tags ) {
            // For descripted routes
            if ( request.route.settings.description ) {
                // Check for each tag
                if (request.route.settings.tags.some( tag => {
                    if (check( `API.${tag}.${request.route.settings.description}`, role.permissions)) {
                        Log.silly(
                            `[${request.headers['X-RequestUID']}] Perm ok "API.${tag}.${request.route.settings.description}"`);
                        return true;
                    }
                    if (check( `autoAPI.${tag}.${request.route.settings.description}`, role.permissions)) {
                        Log.silly(
                            `[${request.headers['X-RequestUID']}] Perm ok "autoAPI.${tag}.${request.route.settings.description}"`);
                        return true;
                    }
                    if (check( `API.${tag}`, role.permissions)) {
                        Log.silly(
                            `[${request.headers['X-RequestUID']}] Perm ok "API.${tag}"`);
                        return true;
                    }
                })) return true;
            }
        }

        // FORBIDDEN
        Log.silly(`[${request.headers['X-RequestUID']}] No permission found ${request.route.method} ${request.route.path} (${request.route.settings.description})`);

        let decorate = {
            routePermissions: auth,
            userPermissions: role.permissions,
            userRole: role.name,
        };

        if(Array.isArray(auth)){
            decorate.routePermissions = auth.map(tag => `API.${tag}.${ request.route.settings.description }`);
        }

        return reply(Boom.forbidden( 'No permission found', {
            decorate: decorate
        }));
    }

    // Get nested value with dot notation
    function check( path, object ) {
        // Separate string
        path = path.split( '.' );

        // Catch undefined
        if ( !object ) return false;
        if ( !object[ path[ 0 ] ] ) return false;
        // It's the targeted value
        if ( path.length == 1 ) {

            // If it's true, continue
            if ( object[ path[ 0 ] ] === true )
                reply.continue();

            // If it's false, block user
            else if ( object[ path[ 0 ] ] === false )
                reply( Boom.forbidden() );

            // If it's a boolean value, stop seeking.
            if ( object[ path[ 0 ] ] === true || object[ path[ 0 ] ] === false )
                return true;

            // Continues deeper
            return false;

        }

        // Deep inspect sub object
        return check( path.slice( 1 )
            .join( '.' ), object[ path[ 0 ] ] );
    }
};
