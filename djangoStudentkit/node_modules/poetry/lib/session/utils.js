// todo: retrieve role for session
const Log = require('../methods/log');
const Models = require('../../models');
const Sessions = Models.sessions;
const Users = Models.users;
const Teams = Models.teams;
const Usergroups = Models.usergroups;
const ObjectID = Models.ObjectID;

const { session, user, team, usergroup } = require('../redis/internal');

const DEBUG_REDIS = process.env.DEBUG_REDIS;

function toObjectID(id) {
  try {
    id = ObjectID(id);
  } catch (err) {}
  return id;
}

function objectIDToString(id) {
  try {
    id = typeof id == 'string' ? id : id.toString();
  } catch (err) {}
  return id;
}

function formatDBDocForRedis(doc, dest) {
  let nv = dest || {};
  Object.keys(doc).forEach((k) => {
    nv[k] = doc[k];
    if (k == '_id' || k == 'role') {
      nv[k] = objectIDToString(nv[k]);
      Log.silly(
        'stringify',
        k,
        ':',
        typeof doc[k],
        doc[k],
        '=>',
        typeof nv[k],
        nv[k]
      );
    }
  });
  return nv;
}

/**
 *
 * @param {*} obj
 * @param {Array<string>} props unused for now (the code knew many changes because of many diferent decisions, gimme a break)
 * @param {Array<string>} props
 */
function formatProps(obj, props, forbiddenProps) {
  /*
  Object.keys(obj).forEach(k => {
    if (!props.includes(k)) {
      delete obj[k];
    }
  })
  */
  if (Array.isArray(forbiddenProps) && forbiddenProps.length) {
    forbiddenProps.forEach((p) => {
      delete obj[p];
    });
  }
}

const onlyPropsUser = [
  'email',
  'isUnlimited',
  'role',
  'status',
  'team',
  '_id',
  'mobileToken',
  'locale',
  'language'
];
const forbiddenPropsUser = [
  'password',
  'createdAt',
  'updatedAt',
  'forgotPwdToken',
  'forgotPwdAt',
  'updatedBy',
  'lastLostPwd',
  'position',
  'picture',
  'phones',
  'addressName',
  'address',
  'zip',
  'city',
  'country',
  'solutionAdmin',
  'expiredAt',
];
const onlyPropsTeam = ['_id', 'permissions', 'solution', 'status', 'maxUsers'];
const forbiddenPropsTeam = [
  //'name',
  //'theme',
  'emailTemplate',
  'createdBy',
  'createdAt',
  'updatedBy',
  'updatedAt',
  'companyName',
  'address',
  'zip',
  'city',
  'country',
  'logo',
  'prefix',
  'level',
  'themeColor',
  'dataRetention',
  'layout',
  'SUPERpermissions',
];
const onlyPropsUsergroup = ['_id', 'permissions', 'team', 'status'];
const forbiddenPropsUsergroup = ['updatedAt', 'updatedBy'];

const saveSessionToCache = async function (sess) {
  if (session) {
    let savedSession = {};
    Object.keys(sess).forEach((k) => {
      savedSession[k] = sess[k];
    });
    try {
      savedSession.user = await SessionUtils.getUserById(savedSession.user);
      if (savedSession.user && savedSession.user._id) {
        savedSession.user._id = savedSession.user._id.toString();
      }
      if (
        savedSession.user &&
        savedSession.user.role &&
        typeof savedSession.user.role != 'string'
      ) {
        savedSession.user.role = savedSession.user.role.toString();
      }
      savedSession.team = await SessionUtils.getTeamById(savedSession.team);
      savedSession.role =
        (await SessionUtils.getRoleById(savedSession.user.role)) || {};
      if (savedSession.role && savedSession.role._id) {
        savedSession.role._id = savedSession.role._id.toString();
      }
    } catch (e) {
      Log.error(e);
    }
    if (DEBUG_REDIS)
      Log.debug('saveSessionToCache:', JSON.stringify(savedSession, null, ' '));
    await session.set(savedSession._id, savedSession);
  }
};

const SessionUtils = {
  async getSession(id) {
    let res;
    try {
      try {
        if (session) {
          res = await session.get(id);
        }
        if (!res) {
          res = await Sessions.findOne({
            _id: id,
          });
          if (res) {
            delete res._cache;
          }
          Log.silly('session from DB', res);
        } else {
          res._cache = true;
        }
      } catch (err) {
        Log.error('getSession error', err);
        res = await Sessions.findOne({
          _id: id,
        });
        Log.silly('session from DB', res);
      }
      if (res && !res._cache) {
        await saveSessionToCache(res);
      }
    } catch (e) {
      Log.error('getSession error 2', e);
    }

    return res;
  },
  async saveSession(sess) {
    try {
      let savedSession = {};
      Object.keys(sess).forEach((k) => {
        savedSession[k] = sess[k];
      });
      if (savedSession.user) {
        if (savedSession.user._id) {
          savedSession.user = savedSession.user._id;
        }

        if (typeof savedSession.user !== 'string') {
          savedSession.user = savedSession.user.toString();
        }
      } else {
        savedSession.user = undefined;
      }

      if (savedSession.team && savedSession.team._id) {
        savedSession.team = savedSession.team._id;
      }

      if (savedSession.isAuthenticated && !savedSession.user) {
        Log.warn('CANNOT INSERT EMPTY USER IN SESSION');
        return;
      }

      delete savedSession._cache;

      await Sessions.save(savedSession);
      await saveSessionToCache(savedSession);
    } catch (e) {
      Log.error(e);
    }
  },
  async deleteSession(id) {
    let res;
    try {
      res = await Sessions.remove({
        _id: id,
      });
      if (session) {
        res = await session.del(id);
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
  async updateSessions(query, updatedProperties) {
    try {
      let sessionIds = await Sessions.distinct('_id', query);
      if (sessionIds.length) {
        await Sessions.updateMany(
          {
            _id: {
              $in: sessionIds,
            },
          },
          {
            $set: updatedProperties,
          }
        );

        if (session) {
          for (const id of sessionIds) {
            try {
              // del from cache
              await session.del(id);
            } catch (e) {
              Log.error(e);
            }
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async deleteSessions(query) {
    try {
      let sessionIds = await Sessions.distinct('_id', query);
      if (sessionIds.length) {
        await Sessions.remove({
          _id: {
            $in: sessionIds,
          },
        });

        if (session) {
          for (const id of sessionIds) {
            try {
              // remove from cache
              await session.del(id);
            } catch (e) {
              Log.error(e);
            }
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async saveUserCache(id, newProps, updateOnly) {
    try {
      let nv = {};
      if (user) {
        // get from cache
        if (!updateOnly) {
          formatDBDocForRedis(newProps, nv);
          formatProps(nv, onlyPropsUser, forbiddenPropsUser);
          await user.set(id, nv);
        } else {
          nv = await user.get(id);
          if (nv) {
            // update cache
            formatDBDocForRedis(newProps, nv);
            formatProps(nv, onlyPropsUser, forbiddenPropsUser);
            await user.set(id, nv);
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async saveTeamCache(id, newProps, updateOnly) {
    try {
      if (team) {
        // get from cache
        if (!updateOnly) {
          formatProps(newProps, onlyPropsTeam, forbiddenPropsTeam);
          await team.set(id, newProps);
        } else {
          let old = await team.get(id);
          if (old) {
            // update cache
            Object.keys(newProps).forEach((k) => {
              old[k] = newProps[k];
            });
            formatProps(old, onlyPropsTeam, forbiddenPropsTeam);
            await team.set(id, old);
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async updateUsersCacheByQuery(query) {
    try {
      if (user) {
        let results = await Users.find(query);
        if (results.length) {
          for (const r of results) {
            try {
              // set cache
              await SessionUtils.saveUserCache(r._id, r);
            } catch (e) {
              Log.error(e);
            }
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async updateTeamsCacheByQuery(query) {
    try {
      if (team) {
        let results = await Teams.find(query);
        if (results.length) {
          for (const r of results) {
            try {
              // set cache
              await team.set(r._id, r);
            } catch (e) {
              Log.error(e);
            }
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async deleteUsersCacheById(id) {
    let res;
    id = toObjectID(id);
    try {
      if (user) {
        res = await user.del(id);
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
  async deleteTeamsCacheById(id) {
    let res;
    try {
      if (team) {
        res = await team.del(id);
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
  async getUserById(id) {
    let res;
    id = toObjectID(id);
    try {
      if (user) {
        res = await user.get(id);
      }
    } catch (err) {
      Log.error(err);
    }
    try {
      if (!res) {
        res = await Users.findOne({ _id: id });
        if (res && user) {
          await SessionUtils.saveUserCache(res._id, res);
        }
        if (res) {
          formatProps(res, onlyPropsUser, forbiddenPropsUser);
        }
      } else {
        formatProps(res, onlyPropsUser, forbiddenPropsUser);
        res._cache = true;
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
  async getTeamById(id) {
    let res;
    try {
      if (team) {
        res = await team.get(id);
      }
    } catch (err) {
      Log.error(err);
    }
    try {
      if (!res) {
        res = await Teams.findOne({ _id: id });
        if (res && team) {
          await team.set(res._id, res);
        }
        if (res) {
          formatProps(res, onlyPropsTeam, forbiddenPropsTeam);
        }
      } else {
        formatProps(res, onlyPropsTeam, forbiddenPropsTeam);
        res._cache = true;
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
  async getRoleById(id) {
    let res;
    id = toObjectID(id);
    try {
      if (usergroup) {
        res = await usergroup.get(id);
      }
    } catch (err) {
      Log.error(err);
    }
    try {
      if (!res) {
        res = await Usergroups.findOne({ _id: id });
        if (res && usergroup) {
          await SessionUtils.saveRoleCache(res._id, res);
        }
        if (res) {
          formatProps(res, onlyPropsUsergroup, forbiddenPropsUsergroup);
        }
      } else {
        formatProps(res, onlyPropsUsergroup, forbiddenPropsUsergroup);
        res._cache = true;
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
  async saveRoleCache(id, newProps, updateOnly) {
    try {
      let nv = {};
      if (usergroup) {
        // get from cache
        if (!updateOnly) {
          formatDBDocForRedis(newProps, nv);
          formatProps(nv, onlyPropsUsergroup, forbiddenPropsUsergroup);
          await usergroup.set(id, nv);
        } else {
          nv = await usergroup.get(id);
          if (nv) {
            // update cache
            formatDBDocForRedis(newProps, nv);
            formatProps(nv, onlyPropsUsergroup, forbiddenPropsUsergroup);
            await usergroup.set(id, nv);
          }
        }
      }
    } catch (e) {
      Log.error(e);
    }
  },
  async deleteRolesCacheById(id) {
    let res;
    id = toObjectID(id);
    try {
      if (usergroup) {
        res = await usergroup.del(id);
      }
    } catch (e) {
      Log.error(e);
    }
    return res;
  },
};

module.exports = SessionUtils;
